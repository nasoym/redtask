#!/bin/bash

function issue() {
  ISSUE_ID=$1
  REDMINE_ISSUE=$(curl -s -3 "https://${SERVER}/issues/${ISSUE_ID}.json?key=${KEY}&include=journals,children")
  REDMINE_SINGLE_ISSUE=$(echo $REDMINE_ISSUE | jq '.issue')
  TASK_JSON=$(echo $REDMINE_SINGLE_ISSUE |\
    jq -c "[if type == \"array\" then .[] else . end | {\
      id: .id, \
      subject: .subject,\
      description: .description,\
      json_description: null,\
      story_points: .story_points,\
      status_name: .status.name, \
      status_id: .status.id, \
      tracker_id: .tracker.id, \
      tracker_name: .tracker.name, \
      fixed_version_id: .fixed_version.id, \
      fixed_version_name: .fixed_version.name, \
      assigned_to_name: .assigned_to.name, \
      assigned_to_id: .assigned_to.id, \
      parent_id: .parent.id, \
      estimated_hours: .estimated_hours, \
      spent_hours: .spent_hours, \
      remaining_hours: ( if has(\"journals\") then \
        ([.journals[] | select( has(\"details\") and ( .details[] | select(.name == \"remaining_hours\") )) | .details[] | select( .name==\"remaining_hours\")] | .[length-1] | if has(\"new_value\") then .new_value | tonumber else null end) \
        else null end ),\
      notes: ( if has(\"journals\") then \
        ([.journals[] | select( has(\"notes\") and .notes !=\"\" ) | {notes: .notes, user_id: .user.id, user_name: .user.name , created_on: .created_on}]) \
        else [] end ),\
      children: (if has(\"children\") then [.children[] | { id: .id, subject: .subject}] else [] end)\
    }]")
  TASK_JSON="$(echo "$TASK_JSON" | jq -c '.[]')"
  #echo "OLD TASK_JSON: >$TASK_JSON<" 1>&2
  DESCRIPTION="$(echo "$TASK_JSON" | jq -r '.description')"
  #echo "DESCRIPTION:>$DESCRIPTION<" 1>&2
  if [ -n "$DESCRIPTION" ] && [ $(assert_json "$DESCRIPTION") ]; then
    #echo "DESCRIPTION IS JSON" 1>&2
    TASK_JSON=$(echo "$TASK_JSON" | jq -c ".json_description=$DESCRIPTION")
    #echo "NEW TASK_JSON: >$TASK_JSON<" 1>&2
  fi
  echo "$TASK_JSON"
}

function load_json_of_ids() {
  IDS=$1
  DEPTH=$2
  if [ -n "$DEPTH" ];then
    NEXT_DEPTH=$(( DEPTH - 1 ))
  else
    DEPTH=0
  fi
  ALL_TASKS_JSON="["
  FIRST_ELEMENT=true
  for ID in $IDS
  do
    TASK_JSON=$(issue $ID)

      if [ "$DEPTH" -gt 0 ];then
        CHILD_IDS=$(echo "$TASK_JSON" | jq -r ".children[] | .id")
        if [ -n "$CHILD_IDS" ];then
          CHILD_TASKS_JSON="$(load_json_of_ids "$CHILD_IDS" $NEXT_DEPTH)"
          TASK_JSON=$(echo "$TASK_JSON" | jq -c ".children=$CHILD_TASKS_JSON")
        fi
      fi

    if [ "$FIRST_ELEMENT" = true ]; then
      FIRST_ELEMENT=false
    else
      ALL_TASKS_JSON="${ALL_TASKS_JSON},"
    fi
    ALL_TASKS_JSON="${ALL_TASKS_JSON}${TASK_JSON}"
  done
  ALL_TASKS_JSON="${ALL_TASKS_JSON}]"
  echo "$ALL_TASKS_JSON"
}

function load_json_content_of_ids() {
  if [ -z "$ALL_TASKS_JSON" ] && [ -n "$IDS" ];then
    echo " load json of ids" 1>&2
    ALL_TASKS_JSON="$(load_json_of_ids "$IDS" $CHILD_DEPTH)"
  elif [ -z "$ALL_TASKS_JSON" ] && [ -z "$IDS" ];then
    echo "no content" 1>&2
    ALL_TASKS_JSON="[]"
  fi
}

while true;do
  if [ "$#" -ge 1 ]; then
    if [ $(echo "$1" | grep "^[0-9]*\(,[0-9]*\)*$") ]; then
      IDS=$(echo "$1" | tr ',' '\n')
      shift

    elif [ $(echo "$1" | grep "ids:[a-zA-Z0-9_-]\{1,\}") ]; then
      VARIABLE_NAME=$(echo "$1" | sed 's/^ids://g')
      shift
      #TODO: how to append to existing id list
      IDS="$(eval $VARIABLE_NAME)"

    elif [ $(echo "$1" | grep "json:[a-zA-Z0-9_-]\{1,\}") ]; then
      VARIABLE_NAME=$(echo "$1" | sed 's/^json://g')
      shift
      #TODO: how to append exisiting json
      ALL_TASKS_JSON="$(eval $VARIABLE_NAME)"
      IDS="$( ids_from_json_array "$ALL_TASKS_JSON" )"

    elif [ "$1" = "test_filter" ]; then
      shift
      load_json_content_of_ids
      ALL_TASKS_JSON=$(echo "$ALL_TASKS_JSON" | jq -c '[.[]| select(.story_points>2.5)]' )

    elif [ "$1" = "open" ]; then
      shift
      load_json_content_of_ids
      #TODO: run filter on all child issues
      #echo '{"a":44,"b":[{"a":1},{"a":2},{"a":3}]}' | jq -c '.b= (.b | del(.[] | select(.a<2)) )'
      #echo '[{"a":44,"b":[{"a":1},{"a":2},{"a":3}]},{"a":55,"b":[{"a":99}]}]' | jq -c '[.[] | .b= (.b | del(.[] | select(.a<2)) )]'
      ALL_TASKS_JSON=$(echo "$ALL_TASKS_JSON" | jq -c '[.[] | .children=(.children | del(.[] | select(.status_id == 5 or .status_id == 6)) )]')

    elif [ $(echo "$1" | grep "\<assigned:[a-zA-Z0-9_-]*\>") ]; then
      USER_ID=$(echo "$1" | sed 's/^assigned://g')
      shift
      #TODO: how to provide a list of assignees
      ALL_TASKS_JSON=$(echo "$ALL_TASKS_JSON" | jq -c "[.[]| select(.assigned_to.id==$USER_ID)]" )

    elif [ "$1" = "custom" ]; then
      shift
      ALL_TASKS_JSON="$(parse_custom_json_field "$ALL_TASKS_JSON" "$IDS")"

    elif [ "$1" = "hirachy" ]; then
      shift
      #TODO: what to do with issues whos parent is not in the json structure
      #TODO: what to do with grandchildren
      #TODO: what to do when the children structure is already filled in the minimal form
      NO_PARENT="$(echo "$ALL_TASKS_JSON" | jq -c '[.[] | select(has("parent")|not)]')"
      WITH_PARENT="$(echo "$ALL_TASKS_JSON" | jq -c '[.[] | select(has("parent"))]')"
      IDS_WITH_PARENT="$(echo "$WITH_PARENT" | jq '.[]|.id')"
      for ID in $IDS_WITH_PARENT; do
        JSON="$(echo "$WITH_PARENT" | jq -r ".[]| select(.id==$ID)")"
        PARENT="$(echo "$JSON" | jq '.parent.id')"
        NO_PARENT="$(echo "$NO_PARENT" | jq -c "[.[] | if .id==$PARENT then .children+=[$JSON] else . end]")"
      done
      ALL_TASKS_JSON="$NO_PARENT"
      IDS="$( ids_from_json_array "$ALL_TASKS_JSON" )"

    else
      break
    fi
  else
    break
  fi
done
