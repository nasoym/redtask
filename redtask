#!/bin/bash

SCRIPT_PATH=$(dirname $0)
source $SCRIPT_PATH/_redmine_api_config_file

: ${ISSUE_LIMIT:="400"}
: ${USER_ID:="me"}

PARSED_OPTIONS=""
while getopts "p:s:elja" options; do
  PARSED_OPTIONS="${PARSED_OPTIONS} -${options}${OPTARG}"
  case $options in
    p )
        PROJECT_ID=$OPTARG
        ;;
    s )
        SPACES=$OPTARG
        ;;
    e )
        EXTENDED=1
        ;;
    l )
        LINE=1
        ;;
    a )
        APPEND=1
        ;;
    j )
        JSON_PRETTY=1
        ;;
   \? ) 
        exit 1
        ;;
  esac
done
shift $(( OPTIND - 1 ));

if [ -z "$SERVER" ] || [ -z "$PROJECT_ID" ] || [ -z "$KEY" ]; then
  echo "SERVER,PROJECT_ID or KEY variable are not defined." >&2
  echo "  These variables should either be defined as environments variables," >&2
  echo "  or in a .redmine file in the current directory or the users home directory." >&2
  exit 1
fi

function issue() {
  ISSUE_ID=$1
  REDMINE_ISSUE=$(curl -s -3 "https://${SERVER}/issues/${ISSUE_ID}.json?key=${KEY}&include=journals,children")
  REDMINE_SINGLE_ISSUE=$(echo $REDMINE_ISSUE | jq '.issue')
  TASK_JSON=$(echo $REDMINE_SINGLE_ISSUE |\
    jq -c "[if type == \"array\" then .[] else . end | {\
      id: .id, \
      subject: .subject,\
      description: .description,\
      story_points: .story_points,\
      status_name: .status.name, \
      status_id: .status.id, \
      tracker_id: .tracker.id, \
      tracker_name: .tracker.name, \
      fixed_version_id: .fixed_version.id, \
      fixed_version_name: .fixed_version.name, \
      assigned_to_name: .assigned_to.name, \
      assigned_to_id: .assigned_to.id, \
      parent_id: .parent.id, \
      estimated_hours: .estimated_hours, \
      spent_hours: .spent_hours, \
      remaining_hours: ( if has(\"journals\") then \
        ([.journals[] | select( has(\"details\") and ( .details[] | select(.name == \"remaining_hours\") )) | .details[] | select( .name==\"remaining_hours\")] | .[length-1] | if has(\"new_value\") then .new_value | tonumber else null end) \
        else null end ),\
      notes: ( if has(\"journals\") then \
        ([.journals[] | select( has(\"notes\") and .notes !=\"\" ) | {notes: .notes, user_id: .user.id, user_name: .user.name , created_on: .created_on}]) \
        else [] end ),\
      children: (if has(\"children\") then [.children[] | { id: .id, subject: .subject}] else [] end)\
    }]")
  echo "$TASK_JSON"
}

function task_line_from_json(){
    : ${SPACES:=''}
    if [ "${EXTENDED}" == "1" ]; then
      # TODO: when the description contains new lines ('\r\n')
      #       the result is strange
      jq -r -c "(if type == \"array\" then .[] else . end |\
\"${SPACES}\(.id): [\(.spent_hours//\"!\")-\(.remaining_hours//\"!\")-\(.estimated_hours//\"!\")] \(.status_name) [\(.assigned_to_name)] : \(.subject) - \(.parent_id//\"\") \
\(.fixed_version_name) \
\(if (.description != null) and (.description != \"\") then (\"\n${SPACES}    \(.description)\") else \"\" end) \
\(if (.notes | length) > 0 then ([.notes[] |\"\n${SPACES}    note: \(.notes)\"]| add ) else \"\" end) \
\"\
      )"
#\"${SPACES}\(.id): [\(.spent_hours//\"!\")-\(.remaining_hours//\"!\")-\(.estimated_hours//\"!\")] \(.status_name) [\(.assigned_to_name)] : \(.subject) - \(.parent_id) \(. fixed_version_name//\"\")\"\
    else
      echo "$1" | jq -r "(if type == \"array\" then .[] else . end |\
\"${SPACES}\(.id): [\(.spent_hours//\"!\")-\(.remaining_hours//\"!\")-\(.estimated_hours//\"!\")] \(.status_name) [\(.assigned_to_name)] : '\(.subject)'\"\
      )"
    fi
}

function write_issue() {
  ISSUE_ID=$1
  VALUES=$2
  echo "$VALUES" | sed -e "s/^/{'issue':{/g" -e "s/$/}}/g" -e "s/'/\"/g" |\
  curl -X PUT -H "Content-type:application/json" -s -3 -d @- "https://${SERVER}/issues/${ISSUE_ID}.json?key=${KEY}"
}

function assert_json() {
  echo "$1" | jq -e '.' >/dev/null 2>&1 && echo "a"
}

function load_json_of_ids() {
  IDS=$1
  DEPTH=$2
  if [ -n "$DEPTH" ];then
    NEXT_DEPTH=$(( DEPTH - 1 ))
  else
    DEPTH=0
  fi
  ALL_TASKS_JSON="["
  FIRST_ELEMENT=true
  for ID in $IDS
  do
    TASK_JSON=$(issue $ID | jq -c '.[]')

      if [ "$DEPTH" -gt 0 ];then
        CHILD_IDS=$(echo "$TASK_JSON" | jq -r ".children[] | .id")
        if [ -n "$CHILD_IDS" ];then
          CHILD_TASKS_JSON="$(load_json_of_ids "$CHILD_IDS" $NEXT_DEPTH)"
          TASK_JSON=$(echo "$TASK_JSON" | jq -c ".children=$CHILD_TASKS_JSON")
        fi
      fi

    if [ "$FIRST_ELEMENT" = true ]; then
      FIRST_ELEMENT=false
    else
      ALL_TASKS_JSON="${ALL_TASKS_JSON},"
    fi
    ALL_TASKS_JSON="${ALL_TASKS_JSON}${TASK_JSON}"
  done
  ALL_TASKS_JSON="${ALL_TASKS_JSON}]"
  echo "$ALL_TASKS_JSON"
}


if [ "$#" -ge 1 ]; then
  if [ $(echo "$1" | grep "^[0-9]*\(,[0-9]*\)*$") ]; then
    IDS=$(echo "$1" | tr ',' '\n')
    shift
    ALL_TASKS_JSON="$(load_json_of_ids "$IDS" 0)"


    if [ "$1" = "sub" ]; then
      if [ -n "$2" ]; then
        for ID in $IDS
        do
          SUBJECT=$(echo "$ALL_TASKS_JSON" | jq -r ".[]| select(.id==$ID)|.subject")
          if [ -n "$APPEND" ]; then
            write_issue $ID "'subject':'$SUBJECT$2'"
          else
            write_issue $ID "'subject':'$2'"
          fi
        done
      else 
        echo "$ALL_TASKS_JSON" | jq -r '.[] | .subject'
      fi
    elif [ "$1" = "des" ]; then
      if [ -n "$2" ]; then
        for ID in $IDS
        do
          VALUE=$(echo "$ALL_TASKS_JSON" | jq -r ".[]| select(.id==$ID)|.description")
          if [ -n "$APPEND" ]; then
            write_issue $ID "'description':'$VALUE$2'"
          else
            write_issue $ID "'description':'$2'"
          fi
        done
      else 
        echo "$ALL_TASKS_JSON" | jq -r '.[] | .description'
      fi
    elif [ "$1" = "jdes" ]; then
      if [ -n "$2" ]; then
        for ID in $IDS
        do
          OLD_VALUE=$(echo "$ALL_TASKS_JSON" | jq -r ".[]| select(.id==$ID)|.description")
          if [ -n "$APPEND" ]; then
            if [ $(assert_json "$OLD_VALUE") ]; then
              #redtask 3126 des "{\\\"hi\\\":4}"
              # $2='.a="4" | .b=5'
              if [ -z "$OLD_VALUE" ];then
                OLD_VALUE="{}"
              fi
              NEW_VALUE=$(echo "$OLD_VALUE" | jq -c "$2" | sed -e 's/"/\\\"/g')
              write_issue $ID "'description':'$NEW_VALUE'"
            else
              echo "description was not a json content"
            fi
          else
            NEW_VALUE=$(echo "$2" | sed -e 's/"/\\\"/g')
            write_issue $ID "'description':'$NEW_VALUE'"
          fi
        done
      else 
        for ID in $IDS
        do
          OLD_VALUE=$(echo "$ALL_TASKS_JSON" | jq -r ".[]| select(.id==$ID)|.description")
          if [ $(assert_json "$OLD_VALUE") ]; then
            :
          else
            echo "description was not a json content"
          fi
          echo "$OLD_VALUE"
        done
      fi

    else
      echo "$ALL_TASKS_JSON"
    fi

  fi
fi

